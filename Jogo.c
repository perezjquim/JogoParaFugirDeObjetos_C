// Projeto 3 de Arquitetura de Computadores
// Jogo para fugir de objetos (C)
// Manuel Joaquim Andrade Sousa Perez, 2029015
// Cláudio Ascenso Sardinha, 2030215

/*	Livrarias	*/
#include <reg51.h>
#include <stdio.h>
#include <stdlib.h>
/**************/

/*	Portas	*/
sbit Input = P3;
#define DisplayX P2
#define DisplayY P1
/************/

/* Constantes auxiliares (microcontrolador) */
#define TEMPO_T0_HIGH	0x3C	 								// Byte mais significativo do timer 0 - 50 ms (12MHz)
#define TEMPO_T0_LOW	0xAF	 									// Byte menos significativo do timer 0 - 50 ms (12MHz)
#define TEMPO_T1 0x70	   									// 0x70 Tempo do timer 1 - 112 us (12MHz)
#define VAZIO 0xFF												// Porta vazia (tudo desligado)
#define INTERRUPCOES_SETUP 143		// Estado das interrupções ao ser corrido o programa
/********************************************/

/*	Constantes auxiliares (jogo)	*/
#define IMAGEM_GAMEOVER 5						// ID da imagem do gameover
#define IMAGEM_VICTORY 6							// ID da imagem da vitória
#define NR_IMAGENS 7					// Número de imagens
#define NR_LINHAS	7						// Número total de linhas
#define POS_JOGADOR 6					// Coordenada Y do jogador (última linha)
#define POS_JOGADOR_INICIAL 4					// Posição inicial do jogador (no meio da linha)
#define VIDAS_INICIAL 4				// Nº de vidas para o jogador (3 vidas)
#define DIFICULDADE1 5				// Velocidade a que descem os obstáculos (dificuldade)
#define DIFICULDADE2 4				// Velocidade a que descem os obstáculos (dificuldade)
#define DIFICULDADE3 3 			// Velocidade a que descem os obstáculos (dificuldade)
#define DIFICULDADE4 2 			// Velocidade a que descem os obstáculos (dificuldade)
#define DIFICULDADE5 1  			// Velocidade a que descem os obstáculos (dificuldade)
#define LIMITE_X_DIREITA 1		// Limite direito do display em relação ao X
#define LIMITE_X_ESQUERDA 16	// Limite esquerdo do display em relação ao X
#define LINHA_VAZIA 0					// Representa uma linha vazia (imagem com os LEDs todos desligados)
/**********************************/

/*	Variáveis do jogo	*/
char LinhaAtual;						// Variável para guardar o número de linha
char ImagemDisplay[NR_LINHAS];		// Display com 7 valores

char VidasRestantes;				// Vidas restantes do jogador
char TempoObstaculos; 			// Tempo (restante) antes de descerem (novamente) os obstáculos
char DificuldadeAtual;			// Dificuldade atual do jogo (tempo estipulado para a frequência com que os obstáculos vão descendo)
char ObstaculosInicio;			// Limite superior dos obstáculos
char NivelAtual = 1;				// Nível atual do jogo (que representa a imagem do vetor a ser desenhada)
/**********************/

/*	Conjunto de imagens do jogo	*/
static char Imagens[NR_IMAGENS][NR_LINHAS - 1] = 
{{3, 2, 1, 6, 0, 0},		// Nível 1
{4, 3, 2, 6, 0, 0},		// Nível 2
{7, 6, 2, 6, 0, 0},		// Nível 3
{8, 2, 3, 6, 0, 0},		// Nível 4
{1, 4, 4, 6, 0, 0},		// Nível 5
{17,10,4,10,17,0},      // Game over
{31,31,31,31,31,31}};	// Vitória
/********************************/

/*	Vetor para ativar as linhas do display	*/
static char ImagemLinha[NR_LINHAS] = 
{254, 253, 251, 247, 239, 223, 191};
/********************************************/

/* Função para desenhar uma nova imagem no ecrã	*/
void desenharNovaImagem(char NovaImagem)
{
   int i;				
   for (i = 0; i < POS_JOGADOR; i++)
      ImagemDisplay[i] = Imagens[NovaImagem][i];		//Atualiza a linha com a nova imagem
}
/************************************************/

/* Função para mover todos os obstáculos (uma "casa" para baixo)	*/
void moverObstaculos()
{
	int i;
	for (i = POS_JOGADOR - 1; i > ObstaculosInicio ; i--)			//Percorre todas as linhas
			ImagemDisplay[i] = ImagemDisplay[i-1]; 							//Puxa a imagem da linha (acima) para baixo
	if(ObstaculosInicio < NR_LINHAS - 1)				//Se os obstáculos ainda não chegaram até ao fim
	{
		ImagemDisplay[ObstaculosInicio] = LINHA_VAZIA;	//Apaga a "primeira" linha dos obstáculos
		ObstaculosInicio++;												//Incrementa a posição onde "começam" os obstáculos
	}
}
/******************************************************************/

/*	Função para verificar se há colisão entre o jogador e um obstáculo	*/
void verificarColisoes(void)
{
	if(ImagemDisplay[POS_JOGADOR] & ImagemDisplay[POS_JOGADOR - 1]) //Se houver "interseção" (colisão)
		VidasRestantes--;																									 //Decrementa a quantidade de vidas restantes
}
/************************************************************************/

/* Função para mover o jogador para a esquerda (quando é premido o devido botão)	*/
void moverJogadorEsquerda() interrupt 0
{
	if(ImagemDisplay[POS_JOGADOR] != LIMITE_X_ESQUERDA)	//Se não tiver encostado na borda esquerda
		ImagemDisplay[POS_JOGADOR] *= 2; 									//O jogador anda para a esquerda (shift left)
}
/********************************************************************6**************/

/* Função para mover o jogador para a direita (quando é premido o devido botão)	*/
void moverJogadorDireita() interrupt 2
{
	if(ImagemDisplay[POS_JOGADOR] != LIMITE_X_DIREITA)	//Se não tiver encostado na borda direita
		ImagemDisplay[POS_JOGADOR] /= 2;									//O jogador anda para a direita (shift right)
}
/********************************************************************************/

/*	Função de controlo para os obstáculos	(que é feita a cada segundo)	*/
/*	(verificar se há colisão e movê-los para baixo)											*/
void verificarObstaculos() interrupt 1
{ 
	 // Reinicializa o timer
   TH0 = TEMPO_T0_HIGH;			
   TL0 = TEMPO_T0_LOW;
	
   TempoObstaculos--;						// Decrementa a contagem (de 1 segundo)
	
	 // Caso a contagem tenha chegado ao fim,
	 // Passa às verificações e ações dos obstáculos
   if (TempoObstaculos == 0)		
   {
		 	verificarColisoes();							// Verifica se há colisão entre o jogador e um obstáculo
			TempoObstaculos = DificuldadeAtual;		// Reinicializa a contagem
			moverObstaculos();										// Move os obstáculos para baixo
   }
}
/************************************************************************/

/*	Função para varrer o display	*/
void varrerDisplay(void) interrupt 3
{
   DisplayY = VAZIO;								// Desliga todas as linhas de sa?da
   DisplayX = ImagemDisplay[LinhaAtual];	// Mostra a linha
   DisplayY = ImagemLinha[LinhaAtual];	// Activa a linha
   LinhaAtual++;										// Passa para a próxima linha
	
   if (LinhaAtual == NR_LINHAS) 		// Caso tenha chegado à ultima linha,
		LinhaAtual = 0;									// Passa novamente para a primeira linha
}
/**********************************/

/*	Função para desenhar os obstáculos pela primeira vez	*/
/*	(consoante a imagem (dos obstáculos) do devido nível)	*/
void inicializarObstaculos()
{
	 ObstaculosInicio = 0;						// A "primeira" linha dos obstáculos começa no topo do display
     desenharNovaImagem(NivelAtual - 1);						// Desenha a imagem do nível atual
}
/**********************************************************/

/*	Função para desenhar pela primeira vez o jogador (na sua posição inicial)	*/
void inicializarJogador()
{
	 ImagemDisplay[POS_JOGADOR] = POS_JOGADOR_INICIAL;	//O jogador fica na sua posição inicial
}
/******************************************************************************/

/*	Função para ligar as interrupções (com o estado adequado)	*/
void ligarInterrupcoes(void)
{
   TMOD = 33;													// Timer 0 de 16 bits - #00100001b
   TH0 = TEMPO_T0_HIGH;									// Timer 0 = 50 ms
   TL0 = TEMPO_T0_LOW; 
   TH1 = TEMPO_T1;										// Timer 1 = 112 us
   TL1 = TEMPO_T1; 
   IP = 0;														// Não altera as prioridades
   IE = INTERRUPCOES_SETUP;	// Activa as interrupções - #10001111b:
   IT0 = 1;														// Ext0 detectada na transição descendente
   IT1 = 1;														// Ext1 detectada na transição descendente
   TR0 = 1;														// Inicia timer 0
   TR1 = 1;														// Inicia timer 1
   Input = VAZIO;											// Porta de entrada é limpa
}
/**************************************************************/

/*	Função para desligar as interrupções */
void desligarInterrupcoes(void)
{
	TR0 = 0;									// Desliga o timer do verificarObstáculos (que traz os obstáculos para baixo)
}
/*****************************************/

/* Função para mostrar a imagem de GameOver (quando o jogador perde todas as vidas num nível)	*/
void gameOver()
{
	desenharNovaImagem(IMAGEM_GAMEOVER);			//Desenha essa imagem
	desligarInterrupcoes();
	for(;;);									//Fica em loop
}
/**********************************************************************************************/

/* Função para mostrar a imagem da vitória (quando o jogador passa com sucesso por todos os níveis)	*/
void victory()
{
	desenharNovaImagem(IMAGEM_VICTORY);			//Desenha essa imagem
	desligarInterrupcoes();
	for(;;);									//Fica em loop
}
/****************************************************************************************************/

/* Função para jogar um dado nível do jogo */
void jogar(double dificuldade)
{
	//Busca no argumento 'dificuldade' o tempo que demora os obstáculos a descer
	DificuldadeAtual = dificuldade;			
	TempoObstaculos = DificuldadeAtual;
	
	inicializarJogador();							//O jogador é inicializado no display
	inicializarObstaculos();					//Os obstáculos do nível são inicializados no display

	//Ciclo do jogo propriamente dito
	while(VidasRestantes && ObstaculosInicio < NR_LINHAS - 1) {}
	
	//Caso tenha acabado o nível com sucesso,
	//Passa para o próximo nível
	if(VidasRestantes)
	{
		NivelAtual++;		
		return;
	}
	
	//Caso contrário,
	//Mostra a imagem de GameOver
	gameOver();
}
/*******************************************/

/********************************************/
/*						Função principal							*/
/********************************************/
void main()
{
	LinhaAtual = 0;	     							// Indica que é para mostrar a primeira linha
	ligarInterrupcoes();			//Liga as interrupções
	VidasRestantes = VIDAS_INICIAL;		//vidas restantes do jogador é inicializada
	
	jogar(DIFICULDADE1);			//Nível 1 do jogo
	jogar(DIFICULDADE2);			//Nível 2 do jogo
	jogar(DIFICULDADE3);			//Nível 3 do jogo
	jogar(DIFICULDADE4);			//Nível 4 do jogo
	jogar(DIFICULDADE5);			//Nível 5 do jogo

	//Caso tenha passado por todos os níveis sem perder as vidas todas
	//Mostra a imagem da vitória
	victory();
}
/********************************************/
/********************************************/